---
# Ensure required inputs are present
- name: Check that operator name has been provided
  ansible.builtin.assert:
    that:
      - install_operator_name | default('') | length > 0
    fail_msg: install_operator_name must be set.

# Optional: create / ensure operator namespace when not using the cluster-wide default
- name: "Set up for Namespace other than 'openshift-operators' ({{ install_operator_name }})"
  when: install_operator_namespace != "openshift-operators"
  block:
    - name: "Ensure Namespace exists ({{ install_operator_name }})"
      kubernetes.core.k8s:
        state: present
        api_version: v1
        kind: Namespace
        name: "{{ install_operator_namespace }}"

    # Split into two tasks to avoid Jinja precedence issues
    - name: "Ensure OperatorGroup exists (AllNamespaces scope)"
      when: (install_operator_manage_namespaces | default([]) | length) == 0
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: operators.coreos.com/v1
          kind: OperatorGroup
          metadata:
            name: "{{ install_operator_operatorgroup_name | default(install_operator_namespace) }}"
            namespace: "{{ install_operator_namespace }}"
 
    - name: "Ensure OperatorGroup exists (targeted namespaces)"
      when: (install_operator_manage_namespaces | default([]) | length) > 0
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: operators.coreos.com/v1
          kind: OperatorGroup
          metadata:
            name: "{{ install_operator_operatorgroup_name | default(install_operator_namespace) }}"
            namespace: "{{ install_operator_namespace }}"
          spec:
            targetNamespaces: "{{ install_operator_manage_namespaces }}"

# Optional: create a custom CatalogSource if requested (air-gapped / snapshot)
- name: "Create/ensure CatalogSource ({{ install_operator_catalogsource_name }})"
  when: install_operator_catalogsource_setup | default(false)
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: operators.coreos.com/v1alpha1
      kind: CatalogSource
      metadata:
        name: "{{ install_operator_catalogsource_name }}"
        namespace: "{{ install_operator_catalogsource_namespace | default('openshift-marketplace') }}"
      spec:
        displayName: "{{ install_operator_catalogsource_displayname | default(install_operator_catalogsource_name) }}"
        publisher: "{{ install_operator_catalogsource_publisher | default('Local') }}"
        sourceType: grpc
        image: "{{ install_operator_catalogsource_image }}:{{ install_operator_catalogsource_image_tag }}"
        updateStrategy:
          registryPoll:
            interval: "{{ install_operator_catalogsource_poll_interval | default('10m') }}"

# Create/ensure Subscription for the operator
- name: "Create Subscription ({{ install_operator_name }})"
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: operators.coreos.com/v1alpha1
      kind: Subscription
      metadata:
        name: "{{ install_operator_name }}"
        namespace: "{{ install_operator_namespace }}"
      spec:
        name: "{{ install_operator_packagemanifest_name | default(install_operator_name) }}"
        channel: "{{ install_operator_channel | default('stable') }}"
        source: "{{ (install_operator_catalogsource_setup | default(false)) | ternary(install_operator_catalogsource_name, (install_operator_source | default('redhat-operators'))) }}"
        sourceNamespace: "{{ install_operator_source_namespace | default('openshift-marketplace') }}"
        installPlanApproval: "{{ (install_operator_automatic_install_plan_approval | default(true)) | ternary('Automatic','Manual') }}"

# --- Robust InstallPlan handling starts here ---

# Wait until an InstallPlan exists for this Subscription, regardless of phase
- name: "Wait until InstallPlan exists ({{ install_operator_name }})"
  kubernetes.core.k8s_info:
    api_version: operators.coreos.com/v1alpha1
    kind: InstallPlan
    namespace: "{{ install_operator_namespace }}"
    label_selectors:
      - "operators.coreos.com/{{ install_operator_name }}.{{ install_operator_namespace }}="
  register: r_installplans
  until: r_installplans.resources | length > 0
  retries: "{{ install_operator_installplan_exist_retries | default(40) }}"
  delay: "{{ install_operator_installplan_exist_delay | default(6) }}"

# Pick newest InstallPlan and record basic facts
- name: "Select newest InstallPlan"
  vars:
    _sorted_ips: "{{ r_installplans.resources | sort(attribute='metadata.creationTimestamp') }}"
  set_fact:
    installplan_obj: "{{ _sorted_ips | last }}"
    installplan_name: "{{ (_sorted_ips | last).metadata.name }}"
    installplan_phase: "{{ (_sorted_ips | last).status.phase | default('') }}"
    installplan_requires_approval: >-
      {{
        (
          (_sorted_ips | last).spec.approval | default('Automatic')
        ) == 'Manual' and
        not ((_sorted_ips | last).spec.approved | default(false))
      }}

# Approve the InstallPlan only if manual approval is configured and required
- name: "Approve InstallPlan when required ({{ installplan_name }})"
  when: installplan_requires_approval
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: operators.coreos.com/v1alpha1
      kind: InstallPlan
      metadata:
        name: "{{ installplan_name }}"
        namespace: "{{ install_operator_namespace }}"
      spec:
        approved: true

# Determine CSV name from Subscription (preferred) or fallback to InstallPlan
- name: "Read Subscription to discover current CSV ({{ install_operator_name }})"
  kubernetes.core.k8s_info:
    api_version: operators.coreos.com/v1alpha1
    kind: Subscription
    name: "{{ install_operator_name }}"
    namespace: "{{ install_operator_namespace }}"
  register: r_subscription

- name: "Set CSV name fact"
  set_fact:
    csv_name: >-
      {{
        r_subscription.resources[0].status.currentCSV
        | default(installplan_obj.spec.clusterServiceVersionNames[0])
      }}

# Wait for CSV to reach Succeeded (final readiness signal)
- name: "Wait for CSV {{ csv_name }} to be Succeeded"
  kubernetes.core.k8s_info:
    api_version: operators.coreos.com/v1alpha1
    kind: ClusterServiceVersion
    name: "{{ csv_name }}"
    namespace: "{{ install_operator_namespace }}"
  register: r_csv
  until:
    - r_csv.resources | length > 0
    - r_csv.resources[0].status.phase is defined
    - r_csv.resources[0].status.phase | length > 0
    - r_csv.resources[0].status.phase == "Succeeded"
  retries: "{{ install_operator_wait_csv_retries | default(60) }}"
  delay: "{{ install_operator_wait_csv_delay | default(10) }}"
  ignore_errors: "{{ install_operator_install_csv_ignore_error | default(false) }}"

# Optional: output a friendly summary
- name: "Operator installed summary ({{ install_operator_name }})"
  ansible.builtin.debug:
    msg:
      - "Subscription: {{ install_operator_name }} (ns={{ install_operator_namespace }})"
      - "InstallPlan: {{ installplan_name }} phase={{ installplan_phase }}"
      - "CSV: {{ csv_name }} phase={{ (r_csv.resources[0].status.phase | default('unknown')) if (r_csv is defined and r_csv.resources|length>0) else 'unknown' }}"
